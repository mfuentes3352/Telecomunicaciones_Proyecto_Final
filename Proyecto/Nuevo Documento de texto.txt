En este directorio se encuentran disponibles los códigos utilizados en el trabajo final de
Telecomunicaciones titulado "Captura y análisis de tráfico en redes Modbus TCP para inspección de estado de red en tiempo real.", en el marco de la asignatura Proyecto 2 de la carrera Ingeniería Electrónica de la FCEIA - UNR. Los scripts aquí expuestos pueden ejecutarse en
distintas máquina virtuales que se encuentren conectadas en red. A continuación se detallan sus funcionalidades:


**# ModbusTCP_client.py**

Este script inicia el cliente en el hostlocal, se conecta al servidor Modbus TCP en la dirección IP 192.168.0.77/24, puerto 1502 y comienza a enviar solicitudes de escritura y lectura de múltiples registros. Los valores que desea escribir son generados aleatoriamente en la función generate_random_values(). Se crean valores de 5 variables de forma continua, saber, temperatura del vapor de caldera, presión del vapor de caldera, velocidad angular de la turbina, frecuencia de la corriente eléctrica y potencia generada. Y en un bucle infinito, en cada iteración, solicita escribir estos registros y luego solicita leerlos, e imprime los
valores escritos y leídos por consola.


# ModbusTCP_server_v2.py 

Inicializa un servidor Modbus TCP en el host local, en la dirección IP 192.168.0.82/24, y comienza a escuchar en el puerto 1502. Además, el código tiene definida la estructura de la memoria de aplicación del dispositivo como 4 bloques consecutivos de memoria de 9999 registros cada uno. Estos bloques son asignados a las entradas  discretas, bobinas, registros de entrada y registros de retención. Escucha por el puerto 1502 las indicaciones, cada solicitud activa una acción local de lectura o escritura en la memoria del dispositivo, arma las respuestas Modbus o respuestas de excepción y las envía a los clientes. Si detecta cambios en los registros de retención imprime por pantalla los nuevos valores de registros.


# GUI_v16.py

Este script inicializa / abre la interfaz gráfica de la herramienta de monitoreo, estructurada en pestañas que permiten al usuario capturar y analizar paquetes Modbus TCP, realizar descubrimiento de red, visualizar métricas en tiempo real y gestionar registros.

En él se define la estructura de una unidad de datos de aplicación Modbus, incluyendo la cabecera MBAP y la unidad de datos de protocolo para solicitudes y respuestas, que luego se utiliza para interpretar las tramas recibidas y extraer los campos relevantes del protocolo. 

Asimismo se declara un mapeo de los códigos de función y los códigos de excepción para decodificar las acciones que el servidor debe realizar y mostrar mensajes descriptivos de las operaciones realizadas.

En la Interfaz Gráfica de Usuario se muestran varias pestañas que implementan las diferentes funcionalidades de la herramienta: "Captura Modbus TCP", "Descubrimiento de red", "Métricas de red", "Registro de métricas" y "Alarmas". 

En la pestaña de "Captura Modbus TCP" aparecen tres paneles: uno superior en donde se presenta la lista de los paquetes capturados, uno inferior izquierdo en donde se muestra una vista 
detallada del paquete seleccionado, y uno inferior derecho en el que se muestra 
la vista en hexadecimal del paquete capturado. En la parte superior de la pestaña hay dos botones, uno que permite iniciar la captura de paquetes y otro que permite detenerla, también posee un cuadro de texto que permite al usuario ingresar el numero de paquetes a capturar, lo que establece un límite y al llegar a ese limite detiene la captura automáticamente. 
Para realizar la función de captura se utiliza la función `sniff()` de Scapy. Al interceptar y registrar un paquete, este aparecerá en la tabla del panel superior, luego si lo seleccionamos, en la vista detallada del paquete, en el panel inferior izquierdo, se mostrará información de los campos de todas las capas que componen al paquete. En el campo `info` se muestra información sobre capa 2, 3, 4 y aplicación. Detecta si es una solicitud o una respuesta, y a su vez, provee información detallada sobre la ADU de Modbus (MBAP header + PDU) Con id de transacción, código de función + descripción, dirección de inicio a partir de la cual se desea leer/escribir, número de bobinas/registros a leer/escribir, valores a escribir, si aplica, o valores a leer, así como también códigos de función de excepción y tipos de códigos de excepción en el caso de recibir respuestas de excepción.

En la pestaña de "Descubrimiento de red", aparece una caja de texto en la que se permite escribir el rango de red, en mi caso: 192.168.0.0/24 y al clickear el botón descubrimiento
de red, se realiza un escaneo de la red utilizando nmap y se muestra en una tabla los dispositivos encontrados, que están presentes en la red, con sus respectivas direcciones IP, nombres de host, estado y direcciones MAC. Y en el panel derecho aparece un grafico de la topología de la red.

En la pestaña de "Métricas de red" aparecen dos paneles: en el panel izquierdo se grafican RTT, Jitter y Throughput en función del tiempo, lo que permite un seguimiento visual de su evolución durante la captura. Mientras que en el panel derecho se presenta de manera visual y actualizada los valores instantáneos de RTT, jitter, throughput, el número total de paquetes capturados, la cantidad de tramas correctas y las erróneas.


se muestran en el panel derecho de métricas en tiempo real, ubicado en la pestaña "Métricas de rendimiento", así como en el registro histórico de métricas de la interfaz gráfica. Además, 

se presenta de manera visual y actualizada los valores instantáneos de RTT, jitter, throughput y contadores de tramas. 

en la primera se muestran las métricas
Round Trip Time, Jitter y Throughput que van actualizándose continuamente. Y
en la segunda tabla aparece un conteo del nro. de paquetes capturados, nro. de
tramas correctas y nro. de tramas erróneas.

La interfaz, desarrollada en PyQt5, organiza la interacción en pestañas funcionales:
● Captura Modbus TCP: muestra en una tabla la secuencia de paquetes capturados, junto con su información de detalle y su representación en formato hexadecimal.
● Descubrimiento de red: utiliza la librería Nmap para identificar los hosts activos dentro de un rango de direcciones IP, proporcionando su dirección, nombre de host, estado y dirección MAC. Los dispositivos detectados se representan en una topología lógica de red centrada en un nodo de conmutación.
● Métricas de red: presenta de manera visual y actualizada los valores instantáneos de RTT, jitter, throughput y contadores de tramas.
● Registro de métricas: mantiene un historial temporal de las métricas, lo cual permite analizar la evolución de los parámetros de desempeño durante la captura.
● Alarmas: supervisa en tiempo real el número de tramas erróneas capturadas. Cuando este valor supera el umbral de 30 paquetes, el sistema genera una alerta visual mediante una ventana emergente e incorpora el evento en la tabla de alarmas con la marca temporal y un comentario descriptivo.


implementar la interfaz gráfica de la herramienta de monitoreo, estructurada en pestañas que permiten al usuario capturar y analizar paquetes Modbus TCP, realizar descubrimiento de red, visualizar métricas en tiempo real y gestionar registros


# ModbusTCP_client_v2.py

Activa el cliente en el hostlocal, se conecta al servidor Modbus TCP,
y comienza a escribir multiples bobinas en el mismo, en rigor, escribe
5 bobinas (los valores binarios son generados aleatoriamente).
En un ciclo de ejecución, solicita escribir estas bobinas y luego 
solicita leerlas. Y esto se repite iterativamente


# ModbusTCP_client_error2.py

Este script es una variante del script ModbusTCP_client.py que se utiliza para
crear tramas erróneas deliberadamente con el fin de ver cómo responde el servidor
a las tramas erróneas, es decir, la idea es poner a prueba su capacidad para
construir respuestas de excepción. Se conecta al servidor, y comienza a enviar
solicitudes para escribir múltiples bobinas, y la dirección en la que se pretende
escribir va cambiando continuamente en el intervalo de direcciones validas (0, 9999),
pero tiene la particularidad de que hay un 20% de probabilidades de que la dirección
se salga del rango, y seleccione una dirección ilegal, es decir, fuera del intervalo
(0, 9999), creando a propósito una trama errónea. Y el servidor detectará este error
y responderá con una respuesta de excepción. El sniffer también detectará este error
y lo resaltara en rojo en la GUI, y decodificara el código de función (>0x80) y el 
código de excpeción (01, 02, 03 o 04).
